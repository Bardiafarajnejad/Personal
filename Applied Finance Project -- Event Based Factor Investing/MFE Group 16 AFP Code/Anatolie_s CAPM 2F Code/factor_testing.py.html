<html>
<head>
<title>factor_testing.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #6a8759;}
.s3 { color: #fffb00;}
.s4 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
factor_testing.py</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">pandas </span><span class="s0">as </span><span class="s1">pd</span>
<span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>
<span class="s0">import </span><span class="s1">datetime</span>
<span class="s0">import </span><span class="s1">scipy.stats</span>
<span class="s0">import </span><span class="s1">statsmodels.api </span><span class="s0">as </span><span class="s1">sm</span>
<span class="s0">import </span><span class="s1">plotly.express </span><span class="s0">as </span><span class="s1">px</span>
<span class="s0">import </span><span class="s1">plotly.offline </span><span class="s0">as </span><span class="s1">py</span>
<span class="s0">import </span><span class="s1">plotly.graph_objs </span><span class="s0">as </span><span class="s1">go</span>
<span class="s0">from </span><span class="s1">statsmodels.tsa.ar_model </span><span class="s0">import </span><span class="s1">AutoReg</span>
<span class="s0">from </span><span class="s1">datetime </span><span class="s0">import </span><span class="s1">timedelta</span>
<span class="s0">from </span><span class="s1">plotly.subplots </span><span class="s0">import </span><span class="s1">make_subplots</span>

<span class="s1">data_raw = pd.read_pickle(</span><span class="s2">&quot;afp_data_formatted.pkl&quot;</span><span class="s1">)</span>

<span class="s3"># TODO: Debug</span>
<span class="s3"># filter_colnames = [&quot;tradedate&quot;, &quot;osid&quot;, &quot;symbol&quot;, &quot;sector_group&quot;, &quot;previoustradedate&quot;,</span>
<span class="s3">#                    &quot;alpha&quot;, &quot;pricehigh&quot;, &quot;pricelow&quot;, &quot;priceclose&quot;, &quot;splitfactor&quot;,</span>
<span class="s3">#                    &quot;cumsplitfactor&quot;, &quot;volume&quot;, &quot;pricepctchgd&quot;, &quot;alpha&quot;, &quot;captl&quot;]</span>

<span class="s1">filter_colnames = [</span><span class="s2">&quot;tradedate&quot;</span><span class="s0">, </span><span class="s2">&quot;osid&quot;</span><span class="s0">, </span><span class="s2">&quot;symbol&quot;</span><span class="s0">, </span><span class="s2">&quot;sector_group&quot;</span><span class="s0">, </span><span class="s2">&quot;previoustradedate&quot;</span><span class="s0">,</span>
                   <span class="s2">&quot;alpha&quot;</span><span class="s0">, </span><span class="s2">&quot;priceclose&quot;</span><span class="s0">, </span><span class="s2">&quot;pricepctchgd&quot;</span><span class="s0">, </span><span class="s2">&quot;captl&quot;</span><span class="s1">]</span>

<span class="s3"># TODO: Debug</span>
<span class="s3"># colnames = data_raw.columns</span>
<span class="s3"># for element in colnames:</span>
<span class="s3">#     print(element)</span>

<span class="s1">data = data_raw.filter(filter_colnames)  </span><span class="s3"># Subset data &amp; del raw from environ. to speed up computation</span>
<span class="s0">del </span><span class="s1">data_raw</span>

<span class="s2">&quot;&quot;&quot; 
Pre-processing filtered data 
&quot;&quot;&quot;</span>
<span class="s1">data[</span><span class="s2">&quot;tradedate&quot;</span><span class="s1">] = pd.to_datetime(data[</span><span class="s2">&quot;tradedate&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">format=</span><span class="s2">&quot;%Y%m%d&quot;</span><span class="s1">)</span>
<span class="s1">data[</span><span class="s2">&quot;sector_group&quot;</span><span class="s1">] = data[</span><span class="s2">&quot;sector_group&quot;</span><span class="s1">].fillna(-</span><span class="s4">1</span><span class="s1">)  </span><span class="s3"># Replace NaN sectors with '-1'</span>
<span class="s1">data.rename(columns={</span><span class="s2">&quot;captl&quot;</span><span class="s1">: </span><span class="s2">&quot;shrout&quot;</span><span class="s1">}</span><span class="s0">, </span><span class="s1">inplace=</span><span class="s0">True</span><span class="s1">)  </span><span class="s3"># Note that shares outstanding are reported in millions</span>
<span class="s1">data = data.dropna(subset=[</span><span class="s2">&quot;shrout&quot;</span><span class="s1">])</span>

<span class="s2">&quot;&quot;&quot; 
Finding value-weighted returns 
&quot;&quot;&quot;</span>
<span class="s3"># (!) Determining market cap of each sector</span>
<span class="s1">data[</span><span class="s2">&quot;mktcap&quot;</span><span class="s1">] = (data[</span><span class="s2">&quot;shrout&quot;</span><span class="s1">]) * data[</span><span class="s2">&quot;priceclose&quot;</span><span class="s1">]</span>
<span class="s1">sector_mktcaps = data.groupby([</span><span class="s2">&quot;tradedate&quot;</span><span class="s0">, </span><span class="s2">&quot;sector_group&quot;</span><span class="s1">])[</span><span class="s2">&quot;mktcap&quot;</span><span class="s1">].sum().reset_index()</span>
<span class="s1">data = data.merge(sector_mktcaps</span><span class="s0">, </span><span class="s1">how=</span><span class="s2">&quot;left&quot;</span><span class="s0">, </span><span class="s1">on=[</span><span class="s2">&quot;tradedate&quot;</span><span class="s0">, </span><span class="s2">&quot;sector_group&quot;</span><span class="s1">]</span><span class="s0">,</span>
                  <span class="s1">suffixes=(</span><span class="s2">&quot;&quot;</span><span class="s0">, </span><span class="s2">&quot;_sector&quot;</span><span class="s1">))  </span><span class="s3"># Note marketcap is reported in millions as well.</span>
<span class="s1">agg_mktcap = data.groupby([</span><span class="s2">&quot;tradedate&quot;</span><span class="s1">])[</span><span class="s2">&quot;mktcap&quot;</span><span class="s1">].sum().reset_index()</span>
<span class="s1">data = data.merge(agg_mktcap</span><span class="s0">, </span><span class="s1">how=</span><span class="s2">&quot;left&quot;</span><span class="s0">, </span><span class="s1">on=[</span><span class="s2">&quot;tradedate&quot;</span><span class="s1">]</span><span class="s0">,</span>
                  <span class="s1">suffixes=(</span><span class="s2">&quot;&quot;</span><span class="s0">, </span><span class="s2">&quot;_tot&quot;</span><span class="s1">))</span>
<span class="s0">del </span><span class="s1">agg_mktcap</span>
<span class="s0">del </span><span class="s1">sector_mktcaps</span>

<span class="s3"># (!) Finding change in days &amp; removing irregular occurrences</span>
<span class="s1">data = data.sort_values([</span><span class="s2">&quot;osid&quot;</span><span class="s0">, </span><span class="s2">&quot;tradedate&quot;</span><span class="s1">]).reset_index(drop=</span><span class="s0">True</span><span class="s1">)</span>
<span class="s1">data[</span><span class="s2">&quot;change_in_days&quot;</span><span class="s1">] = data.groupby([</span><span class="s2">&quot;osid&quot;</span><span class="s1">])[</span><span class="s2">&quot;tradedate&quot;</span><span class="s1">].shift(-</span><span class="s4">1</span><span class="s1">) - data[</span><span class="s2">&quot;tradedate&quot;</span><span class="s1">]</span>
<span class="s1">data[</span><span class="s2">&quot;linear_pricepctchgd&quot;</span><span class="s1">] = data[</span><span class="s2">&quot;pricepctchgd&quot;</span><span class="s1">] / data[</span><span class="s2">&quot;change_in_days&quot;</span><span class="s1">].dt.days  </span><span class="s3"># interpolated daily % chg</span>
<span class="s1">data = data[data[</span><span class="s2">&quot;change_in_days&quot;</span><span class="s1">] &lt;= datetime.timedelta(days=</span><span class="s4">10</span><span class="s1">)]  </span><span class="s3"># Delete times where last tradedate &gt; 10 days</span>

<span class="s3"># (!) Finding the value-weighted return of each sector</span>
<span class="s3"># TODO: Note that we're using the interpolated 1d change in price, NOT the actual change in price.</span>
<span class="s1">data[</span><span class="s2">&quot;vwret&quot;</span><span class="s1">] = data[</span><span class="s2">&quot;linear_pricepctchgd&quot;</span><span class="s1">] * (data[</span><span class="s2">&quot;mktcap&quot;</span><span class="s1">] / data[</span><span class="s2">&quot;mktcap_sector&quot;</span><span class="s1">]).copy()</span>
<span class="s1">vwret_by_sector = data.groupby([</span><span class="s2">&quot;tradedate&quot;</span><span class="s0">, </span><span class="s2">&quot;sector_group&quot;</span><span class="s1">])[</span><span class="s2">&quot;vwret&quot;</span><span class="s1">].sum().reset_index()</span>
<span class="s1">data = data.merge(vwret_by_sector</span><span class="s0">, </span><span class="s1">how=</span><span class="s2">&quot;left&quot;</span><span class="s0">, </span><span class="s1">on=[</span><span class="s2">&quot;tradedate&quot;</span><span class="s0">, </span><span class="s2">&quot;sector_group&quot;</span><span class="s1">]</span><span class="s0">,</span>
                  <span class="s1">suffixes=(</span><span class="s2">&quot;&quot;</span><span class="s0">, </span><span class="s2">&quot;_sector&quot;</span><span class="s1">))</span>
<span class="s0">del </span><span class="s1">vwret_by_sector</span>

<span class="s3"># (!) Finding the value-weighted return of the market (universe)</span>
<span class="s1">data[</span><span class="s2">&quot;vwret&quot;</span><span class="s1">] = data[</span><span class="s2">&quot;linear_pricepctchgd&quot;</span><span class="s1">] * (data[</span><span class="s2">&quot;mktcap&quot;</span><span class="s1">] / data[</span><span class="s2">&quot;mktcap_sector&quot;</span><span class="s1">])</span>
<span class="s1">vwret_market = data.groupby([</span><span class="s2">&quot;tradedate&quot;</span><span class="s1">])[</span><span class="s2">&quot;vwret&quot;</span><span class="s1">].sum().reset_index()</span>
<span class="s1">data = data.merge(vwret_market</span><span class="s0">, </span><span class="s1">how=</span><span class="s2">&quot;inner&quot;</span><span class="s0">, </span><span class="s1">on=[</span><span class="s2">&quot;tradedate&quot;</span><span class="s1">]</span><span class="s0">,</span>
                  <span class="s1">suffixes=(</span><span class="s2">&quot;&quot;</span><span class="s0">, </span><span class="s2">&quot;_market&quot;</span><span class="s1">))</span>
<span class="s0">del </span><span class="s1">vwret_market</span>

<span class="s2">&quot;&quot;&quot; 
Compute market risk premium &amp; sector risk premium 
&quot;&quot;&quot;</span>
<span class="s3"># (!) Importing LIBOR-USD from FRED: https://fred.stlouisfed.org/series/USDONTD156N</span>
<span class="s1">FRED_data = pd.read_csv(</span><span class="s2">&quot;FRED_LIBOR.csv&quot;</span><span class="s1">)</span>
<span class="s1">FRED_data.rename(columns={</span><span class="s2">&quot;USDONTD156N&quot;</span><span class="s1">: </span><span class="s2">&quot;LIBOR&quot;</span><span class="s1">}</span><span class="s0">, </span><span class="s1">inplace=</span><span class="s0">True</span><span class="s1">)</span>
<span class="s1">FRED_data[</span><span class="s2">&quot;DATE&quot;</span><span class="s1">] = pd.to_datetime(FRED_data[</span><span class="s2">&quot;DATE&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">format=</span><span class="s2">&quot;%Y-%m-%d&quot;</span><span class="s1">)</span>
<span class="s3"># TODO: We convert LIBOR from % to decimal &amp; approximate a daily value (it is annualized) assuming 250 trading days.</span>
<span class="s1">FRED_data[</span><span class="s2">&quot;LIBOR&quot;</span><span class="s1">] = FRED_data[</span><span class="s2">&quot;LIBOR&quot;</span><span class="s1">].astype(str).replace(</span><span class="s2">&quot;.&quot;</span><span class="s0">, </span><span class="s1">np.nan).astype(float) / </span><span class="s4">100 </span><span class="s1">/ </span><span class="s4">250</span>
<span class="s1">FRED_data[</span><span class="s2">&quot;LIBOR&quot;</span><span class="s1">] = (FRED_data[</span><span class="s2">&quot;LIBOR&quot;</span><span class="s1">].ffill() + FRED_data[</span><span class="s2">&quot;LIBOR&quot;</span><span class="s1">].bfill()) / </span><span class="s4">2  </span><span class="s3"># Linear interp. missing values</span>

<span class="s1">data = data.merge(FRED_data</span><span class="s0">, </span><span class="s1">how=</span><span class="s2">&quot;right&quot;</span><span class="s0">, </span><span class="s1">left_on=[</span><span class="s2">&quot;tradedate&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">right_on=[</span><span class="s2">&quot;DATE&quot;</span><span class="s1">]).dropna(subset=[</span><span class="s2">&quot;osid&quot;</span><span class="s1">])</span>
<span class="s1">data = data.drop(columns=</span><span class="s2">&quot;DATE&quot;</span><span class="s1">)</span>
<span class="s0">del </span><span class="s1">FRED_data</span>

<span class="s3"># (!) Calculating risk premia</span>
<span class="s1">data[</span><span class="s2">&quot;mkt_premium&quot;</span><span class="s1">] = data[</span><span class="s2">&quot;vwret_market&quot;</span><span class="s1">] - data[</span><span class="s2">&quot;LIBOR&quot;</span><span class="s1">]</span>
<span class="s1">data[</span><span class="s2">&quot;sector_premium&quot;</span><span class="s1">] = data[</span><span class="s2">&quot;vwret_sector&quot;</span><span class="s1">] - data[</span><span class="s2">&quot;LIBOR&quot;</span><span class="s1">]  </span><span class="s3"># Sector risk premia</span>

<span class="s2">&quot;&quot;&quot; 
Find sensitivity of each stock w.r.t the market &amp; its sector 
&quot;&quot;&quot;</span>
<span class="s3"># (!) Can also get rolling correl using &quot;.rolling(nper).corr()&quot;; This lets us control for time varying Betas.</span>
<span class="s1">Beta_market = pd.DataFrame()</span>
<span class="s1">Beta_sector = pd.DataFrame()</span>

<span class="s1">market_correl = data.groupby([</span><span class="s2">&quot;osid&quot;</span><span class="s1">])[[</span><span class="s2">&quot;vwret_market&quot;</span><span class="s0">, </span><span class="s2">&quot;linear_pricepctchgd&quot;</span><span class="s1">]].corr().unstack().iloc[:</span><span class="s0">,</span>
                <span class="s4">1</span><span class="s1">].reset_index()</span>
<span class="s1">sector_correl = data.groupby([</span><span class="s2">&quot;osid&quot;</span><span class="s1">])[[</span><span class="s2">&quot;vwret_sector&quot;</span><span class="s0">, </span><span class="s2">&quot;linear_pricepctchgd&quot;</span><span class="s1">]].corr().unstack().iloc[:</span><span class="s0">,</span>
                <span class="s4">1</span><span class="s1">].reset_index()</span>

<span class="s1">Beta_market[</span><span class="s2">&quot;osid&quot;</span><span class="s1">] = market_correl[</span><span class="s2">&quot;osid&quot;</span><span class="s1">]</span>
<span class="s1">Beta_market[</span><span class="s2">&quot;rho&quot;</span><span class="s1">] = market_correl.iloc[:</span><span class="s0">, </span><span class="s4">1</span><span class="s1">]</span>
<span class="s1">Beta_sector[</span><span class="s2">&quot;osid&quot;</span><span class="s1">] = sector_correl[</span><span class="s2">&quot;osid&quot;</span><span class="s1">]</span>
<span class="s1">Beta_sector[</span><span class="s2">&quot;rho&quot;</span><span class="s1">] = sector_correl.iloc[:</span><span class="s0">, </span><span class="s4">1</span><span class="s1">]</span>

<span class="s3"># (!) Merge betas into main DataFrame</span>
<span class="s1">data = data.merge(Beta_market</span><span class="s0">, </span><span class="s1">how=</span><span class="s2">&quot;left&quot;</span><span class="s0">, </span><span class="s1">on=</span><span class="s2">&quot;osid&quot;</span><span class="s0">,</span>
                  <span class="s1">suffixes=(</span><span class="s2">&quot;&quot;</span><span class="s0">, </span><span class="s2">&quot;_market&quot;</span><span class="s1">))</span>
<span class="s1">data.rename(columns={</span><span class="s2">&quot;rho&quot;</span><span class="s1">: </span><span class="s2">&quot;beta_mkt&quot;</span><span class="s1">}</span><span class="s0">, </span><span class="s1">inplace=</span><span class="s0">True</span><span class="s1">)</span>
<span class="s1">data = data.merge(Beta_sector</span><span class="s0">, </span><span class="s1">how=</span><span class="s2">&quot;left&quot;</span><span class="s0">, </span><span class="s1">on=</span><span class="s2">&quot;osid&quot;</span><span class="s0">,</span>
                  <span class="s1">suffixes=(</span><span class="s2">&quot;&quot;</span><span class="s0">, </span><span class="s2">&quot;_sector&quot;</span><span class="s1">))</span>
<span class="s1">data.rename(columns={</span><span class="s2">&quot;rho&quot;</span><span class="s1">: </span><span class="s2">&quot;beta_sector&quot;</span><span class="s1">}</span><span class="s0">, </span><span class="s1">inplace=</span><span class="s0">True</span><span class="s1">)</span>
<span class="s0">del </span><span class="s1">Beta_market</span><span class="s0">, </span><span class="s1">Beta_sector</span><span class="s0">, </span><span class="s1">market_correl</span><span class="s0">, </span><span class="s1">sector_correl</span>

<span class="s2">&quot;&quot;&quot; 
Finding the 2-factor CAPM-implied model return 
&quot;&quot;&quot;</span>
<span class="s1">data[</span><span class="s2">&quot;capm_2f&quot;</span><span class="s1">] = data[</span><span class="s2">&quot;LIBOR&quot;</span><span class="s1">] + \</span>
                  <span class="s1">data[</span><span class="s2">&quot;beta_mkt&quot;</span><span class="s1">] * data[</span><span class="s2">&quot;mkt_premium&quot;</span><span class="s1">] + \</span>
                  <span class="s1">data[</span><span class="s2">&quot;beta_sector&quot;</span><span class="s1">] * data[</span><span class="s2">&quot;sector_premium&quot;</span><span class="s1">]</span>
<span class="s1">data[</span><span class="s2">&quot;epsilon&quot;</span><span class="s1">] = data[</span><span class="s2">&quot;linear_pricepctchgd&quot;</span><span class="s1">] - data[</span><span class="s2">&quot;capm_2f&quot;</span><span class="s1">]  </span><span class="s3"># equiv. of a 2-factor &quot;alpha&quot;</span>
<span class="s1">data[</span><span class="s2">&quot;diff&quot;</span><span class="s1">] = data[</span><span class="s2">&quot;epsilon&quot;</span><span class="s1">] - data[</span><span class="s2">&quot;alpha&quot;</span><span class="s1">]</span>

<span class="s2">&quot;&quot;&quot; 
Create Buy/Sell signals based on our model 
&quot;&quot;&quot;</span>


<span class="s0">def </span><span class="s1">return_10d(df):</span>
    <span class="s1">df[</span><span class="s2">&quot;model_10d&quot;</span><span class="s1">] = (</span><span class="s4">1 </span><span class="s1">+ df[</span><span class="s2">&quot;capm_2f&quot;</span><span class="s1">]).rolling(</span><span class="s4">10</span><span class="s1">).apply(np.prod</span><span class="s0">, </span><span class="s1">raw=</span><span class="s0">True</span><span class="s1">) - </span><span class="s4">1</span>
    <span class="s1">df[</span><span class="s2">&quot;real_10d&quot;</span><span class="s1">] = (</span><span class="s4">1 </span><span class="s1">+ df[</span><span class="s2">&quot;linear_pricepctchgd&quot;</span><span class="s1">]).rolling(</span><span class="s4">10</span><span class="s1">).apply(np.prod</span><span class="s0">, </span><span class="s1">raw=</span><span class="s0">True</span><span class="s1">) - </span><span class="s4">1</span>
    <span class="s0">return </span><span class="s1">df</span>


<span class="s1">data.sort_values([</span><span class="s2">&quot;osid&quot;</span><span class="s0">, </span><span class="s2">&quot;tradedate&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">inplace=</span><span class="s0">True</span><span class="s1">)</span>
<span class="s1">data = data.groupby(</span><span class="s2">&quot;osid&quot;</span><span class="s1">).apply(</span><span class="s0">lambda </span><span class="s1">x: return_10d(x))</span>

<span class="s3"># (!) See notes for economic intuition of this trading strategy</span>
<span class="s1">data[</span><span class="s2">&quot;signal&quot;</span><span class="s1">] = </span><span class="s4">0</span>
<span class="s1">alpha = </span><span class="s4">1.5</span>
<span class="s1">data.loc[data[</span><span class="s2">&quot;real_10d&quot;</span><span class="s1">]*alpha &gt; data[</span><span class="s2">&quot;model_10d&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s2">&quot;signal&quot;</span><span class="s1">] = </span><span class="s4">1</span>


<span class="s2">&quot;&quot;&quot; 
Compute the PnL of this strategy 
&quot;&quot;&quot;</span>

<span class="s1">data = data.reset_index(drop=</span><span class="s0">True</span><span class="s1">)</span>
<span class="s3"># (!) Calculate equally distributed weights of stocks that have a &quot;Buy&quot; signal on this day</span>
<span class="s1">eq_weights = data.groupby(</span><span class="s2">&quot;tradedate&quot;</span><span class="s1">)[</span><span class="s2">&quot;signal&quot;</span><span class="s1">].transform(</span><span class="s0">lambda </span><span class="s1">x: </span><span class="s4">1 </span><span class="s1">/ (np.maximum(np.count_nonzero(x == </span><span class="s4">1</span><span class="s1">)</span><span class="s0">, </span><span class="s4">1</span><span class="s1">)))</span>
<span class="s1">data = data.merge(eq_weights</span><span class="s0">, </span><span class="s1">how=</span><span class="s2">&quot;left&quot;</span><span class="s0">, </span><span class="s1">left_index=</span><span class="s0">True, </span><span class="s1">right_index=</span><span class="s0">True</span><span class="s1">).rename(columns={</span><span class="s2">&quot;signal_y&quot;</span><span class="s1">: </span><span class="s2">&quot;eq_weight&quot;</span><span class="s0">,</span>
                                                                                             <span class="s2">&quot;signal_x&quot;</span><span class="s1">: </span><span class="s2">&quot;signal&quot;</span><span class="s1">})</span>
<span class="s0">del </span><span class="s1">eq_weights</span>
<span class="s1">data[</span><span class="s2">&quot;ewret&quot;</span><span class="s1">] = data[</span><span class="s2">&quot;signal&quot;</span><span class="s1">] * data[</span><span class="s2">&quot;eq_weight&quot;</span><span class="s1">] * data[</span><span class="s2">&quot;linear_pricepctchgd&quot;</span><span class="s1">]  </span><span class="s3"># This is a misnomer - should rename.</span>

<span class="s3"># (!) Create 10 continuously rebalanced portfolios, with start &amp; rebalancing dates staggered 10 trading days apart</span>

<span class="s1">Portfolios = pd.DataFrame()</span>
<span class="s1">Portfolios[</span><span class="s2">&quot;Date&quot;</span><span class="s1">] = data[</span><span class="s2">&quot;tradedate&quot;</span><span class="s1">].unique()</span>
<span class="s1">Portfolios[</span><span class="s2">&quot;Returns&quot;</span><span class="s1">] = </span><span class="s4">1 </span><span class="s1">+ data.groupby(</span><span class="s2">&quot;tradedate&quot;</span><span class="s1">)[</span><span class="s2">&quot;ewret&quot;</span><span class="s1">].agg(</span><span class="s2">&quot;sum&quot;</span><span class="s1">).values</span>
<span class="s1">Portfolios[</span><span class="s2">&quot;Rf&quot;</span><span class="s1">] = data.groupby(</span><span class="s2">&quot;tradedate&quot;</span><span class="s1">)[</span><span class="s2">&quot;LIBOR&quot;</span><span class="s1">].agg(</span><span class="s2">&quot;mean&quot;</span><span class="s1">).values</span>
<span class="s1">Portfolios[</span><span class="s2">&quot;Vwret&quot;</span><span class="s1">] = </span><span class="s4">1 </span><span class="s1">+ data.groupby(</span><span class="s2">&quot;tradedate&quot;</span><span class="s1">)[</span><span class="s2">&quot;vwret&quot;</span><span class="s1">].agg(</span><span class="s2">&quot;sum&quot;</span><span class="s1">).values</span>
<span class="s1">Portfolios.sort_values(</span><span class="s2">&quot;Date&quot;</span><span class="s0">, </span><span class="s1">inplace=</span><span class="s0">True</span><span class="s1">)</span>

<span class="s3"># (!) Find portfolio returns every 10 days</span>

<span class="s3"># Assume transaction cost of both buy &amp; sell is 5bp</span>
<span class="s1">Portfolios[</span><span class="s2">&quot;Benchmark&quot;</span><span class="s1">] = (Portfolios[</span><span class="s2">&quot;Vwret&quot;</span><span class="s1">] - Portfolios[</span><span class="s2">&quot;Vwret&quot;</span><span class="s1">]*</span><span class="s4">0.0005 </span><span class="s1">- </span><span class="s4">0.0005 </span><span class="s1">- Portfolios[</span><span class="s2">&quot;Rf&quot;</span><span class="s1">])\</span>
    <span class="s1">.rolling(</span><span class="s4">10</span><span class="s1">).apply(np.prod</span><span class="s0">, </span><span class="s1">raw=</span><span class="s0">True</span><span class="s1">) - </span><span class="s4">1</span>

<span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(</span><span class="s4">1</span><span class="s0">, </span><span class="s4">11</span><span class="s1">):</span>
    <span class="s1">Portfolios[</span><span class="s2">f&quot;portf.</span><span class="s0">{</span><span class="s1">i</span><span class="s0">}</span><span class="s2">&quot;</span><span class="s1">] = </span><span class="s4">0</span>
    <span class="s1">Portfolios[</span><span class="s2">f&quot;performance.</span><span class="s0">{</span><span class="s1">i</span><span class="s0">}</span><span class="s2">&quot;</span><span class="s1">] = </span><span class="s4">0</span>
    <span class="s1">Portfolios.iloc[</span><span class="s0">lambda </span><span class="s1">x: x.index % </span><span class="s4">10 </span><span class="s1">== i - </span><span class="s4">1</span><span class="s0">, </span><span class="s1">Portfolios.columns.get_loc(</span><span class="s2">f&quot;portf.</span><span class="s0">{</span><span class="s1">i</span><span class="s0">}</span><span class="s2">&quot;</span><span class="s1">)] = </span><span class="s4">1</span>
    <span class="s1">Portfolios[</span><span class="s2">f&quot;portf.</span><span class="s0">{</span><span class="s1">i</span><span class="s0">}</span><span class="s2">&quot;</span><span class="s1">] = Portfolios[</span><span class="s2">f&quot;portf.</span><span class="s0">{</span><span class="s1">i</span><span class="s0">}</span><span class="s2">&quot;</span><span class="s1">] * Portfolios[</span><span class="s2">&quot;Returns&quot;</span><span class="s1">].rolling(</span><span class="s4">10</span><span class="s1">).apply(np.prod</span><span class="s0">, </span><span class="s1">raw=</span><span class="s0">True</span><span class="s1">) - </span><span class="s4">1</span>
    <span class="s1">Portfolios[</span><span class="s2">f&quot;portf.</span><span class="s0">{</span><span class="s1">i</span><span class="s0">}</span><span class="s2">&quot;</span><span class="s1">].replace(-</span><span class="s4">1.0</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">inplace=</span><span class="s0">True</span><span class="s1">)</span>
    <span class="s3"># Incorporating transaction costs for selling &amp; buying</span>
    <span class="s1">Portfolios.loc[Portfolios[</span><span class="s2">f&quot;portf.</span><span class="s0">{</span><span class="s1">i</span><span class="s0">}</span><span class="s2">&quot;</span><span class="s1">] != np.nan</span><span class="s0">, </span><span class="s2">f&quot;portf.</span><span class="s0">{</span><span class="s1">i</span><span class="s0">}</span><span class="s2">&quot;</span><span class="s1">] -= </span><span class="s4">0.0005</span>
    <span class="s1">Portfolios.loc[Portfolios[</span><span class="s2">f&quot;portf.</span><span class="s0">{</span><span class="s1">i</span><span class="s0">}</span><span class="s2">&quot;</span><span class="s1">] != np.nan</span><span class="s0">, </span><span class="s2">f&quot;portf.</span><span class="s0">{</span><span class="s1">i</span><span class="s0">}</span><span class="s2">&quot;</span><span class="s1">] -= (</span><span class="s4">1</span><span class="s1">+Portfolios[</span><span class="s2">f&quot;portf.</span><span class="s0">{</span><span class="s1">i</span><span class="s0">}</span><span class="s2">&quot;</span><span class="s1">])*</span><span class="s4">0.0005 </span><span class="s1">- </span><span class="s4">1</span>
    <span class="s1">Portfolios[</span><span class="s2">f&quot;portf.</span><span class="s0">{</span><span class="s1">i</span><span class="s0">}</span><span class="s2">&quot;</span><span class="s1">] -= </span><span class="s4">1</span>
    <span class="s3"># Record outperformance of benchmark as well</span>
    <span class="s1">Portfolios.loc[Portfolios[</span><span class="s2">f&quot;portf.</span><span class="s0">{</span><span class="s1">i</span><span class="s0">}</span><span class="s2">&quot;</span><span class="s1">] != np.nan</span><span class="s0">, </span><span class="s2">f&quot;performance.</span><span class="s0">{</span><span class="s1">i</span><span class="s0">}</span><span class="s2">&quot;</span><span class="s1">] = Portfolios[</span><span class="s2">f&quot;portf.</span><span class="s0">{</span><span class="s1">i</span><span class="s0">}</span><span class="s2">&quot;</span><span class="s1">] - \</span>
                                                                             <span class="s1">Portfolios[</span><span class="s2">&quot;Benchmark&quot;</span><span class="s1">] - \</span>
                                                                             <span class="s1">Portfolios[</span><span class="s2">&quot;Rf&quot;</span><span class="s1">]</span>

<span class="s1">Portfolios_Agg = pd.DataFrame()</span>
<span class="s1">Portfolios_Agg[</span><span class="s2">&quot;Date&quot;</span><span class="s1">] = Portfolios[</span><span class="s2">&quot;Date&quot;</span><span class="s1">].copy()</span>
<span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(</span><span class="s4">1</span><span class="s0">, </span><span class="s4">11</span><span class="s1">):</span>
    <span class="s1">Portfolios_Agg[</span><span class="s2">f&quot;performance.</span><span class="s0">{</span><span class="s1">i</span><span class="s0">}</span><span class="s2">&quot;</span><span class="s1">] = Portfolios[</span><span class="s2">f&quot;performance.</span><span class="s0">{</span><span class="s1">i</span><span class="s0">}</span><span class="s2">&quot;</span><span class="s1">].values</span>

<span class="s1">Portfolios_Squeezed = pd.DataFrame()</span>
<span class="s1">Portfolios_Squeezed[</span><span class="s2">&quot;Date&quot;</span><span class="s1">] = Portfolios_Agg[</span><span class="s2">&quot;Date&quot;</span><span class="s1">]</span>
<span class="s1">Portfolios_Squeezed[</span><span class="s2">&quot;10d Outperformance&quot;</span><span class="s1">] = np.sum(Portfolios_Agg.iloc[:</span><span class="s0">, </span><span class="s4">1</span><span class="s1">:]</span><span class="s0">, </span><span class="s1">axis=</span><span class="s4">1</span><span class="s1">)</span>

<span class="s1">fig_data = go.Histogram(x=Portfolios_Squeezed[</span><span class="s2">&quot;10d Outperformance&quot;</span><span class="s1">].iloc[</span><span class="s4">9</span><span class="s1">:]</span><span class="s0">, </span><span class="s1">opacity=</span><span class="s4">0.6</span><span class="s0">, </span><span class="s1">histnorm=</span><span class="s2">&quot;probability&quot;</span><span class="s1">)</span>
<span class="s1">layout = go.Layout(barmode=</span><span class="s2">&quot;overlay&quot;</span><span class="s0">,</span>
                   <span class="s1">title=go.layout.Title(text=</span><span class="s2">&quot;Rolling 10d Outperformance vs. Benchmark&quot;</span><span class="s1">)</span><span class="s0">,</span>
                   <span class="s1">xaxis_title=</span><span class="s2">&quot;Outperformance&quot;</span><span class="s0">,</span>
                   <span class="s1">yaxis_title=</span><span class="s2">&quot;Probability Distrib.&quot;</span><span class="s1">)</span>
<span class="s1">fig = go.Figure(data=fig_data</span><span class="s0">, </span><span class="s1">layout=layout)</span>
<span class="s1">py.plot(fig</span><span class="s0">, </span><span class="s1">filename=</span><span class="s2">&quot;Table4_performancehistogram.html&quot;</span><span class="s1">)</span>



<span class="s2">&quot;&quot;&quot; 
Profitability metrics &amp; analysis 
&quot;&quot;&quot;</span>

<span class="s3"># (!) Calculate returns from following our strategy.</span>
<span class="s1">Returns = pd.DataFrame()</span>
<span class="s1">Returns[</span><span class="s2">&quot;Date&quot;</span><span class="s1">] = Portfolios[</span><span class="s2">&quot;Date&quot;</span><span class="s1">]</span>
<span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(</span><span class="s4">1</span><span class="s0">, </span><span class="s4">11</span><span class="s1">):</span>
    <span class="s1">Returns[</span><span class="s2">f&quot;portf.</span><span class="s0">{</span><span class="s1">i</span><span class="s0">}</span><span class="s2">&quot;</span><span class="s1">] = Portfolios[</span><span class="s2">f&quot;portf.</span><span class="s0">{</span><span class="s1">i</span><span class="s0">}</span><span class="s2">&quot;</span><span class="s1">].fillna(method=</span><span class="s2">&quot;ffill&quot;</span><span class="s1">)</span>
<span class="s1">Returns[</span><span class="s2">&quot;Agg Return&quot;</span><span class="s1">] = np.sum(Returns.iloc[:</span><span class="s0">, </span><span class="s4">1</span><span class="s1">:] * </span><span class="s4">0.1</span><span class="s0">, </span><span class="s1">axis=</span><span class="s4">1</span><span class="s1">)</span>
<span class="s1">Returns = Returns.dropna()</span>

<span class="s3"># (!) Calculate log outperformance of the strategy</span>
<span class="s1">Performance = pd.DataFrame()</span>
<span class="s1">Performance[</span><span class="s2">&quot;Date&quot;</span><span class="s1">] = Portfolios[</span><span class="s2">&quot;Date&quot;</span><span class="s1">]</span>
<span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(</span><span class="s4">1</span><span class="s0">, </span><span class="s4">11</span><span class="s1">):</span>
    <span class="s1">Performance[</span><span class="s2">f&quot;portf.</span><span class="s0">{</span><span class="s1">i</span><span class="s0">}</span><span class="s2">&quot;</span><span class="s1">] = Portfolios[</span><span class="s2">f&quot;performance.</span><span class="s0">{</span><span class="s1">i</span><span class="s0">}</span><span class="s2">&quot;</span><span class="s1">].fillna(method=</span><span class="s2">&quot;ffill&quot;</span><span class="s1">)</span>
<span class="s1">Performance[</span><span class="s2">&quot;Agg Performance&quot;</span><span class="s1">] = np.sum(Performance.iloc[:</span><span class="s0">, </span><span class="s4">1</span><span class="s1">:] * </span><span class="s4">0.1</span><span class="s0">, </span><span class="s1">axis=</span><span class="s4">1</span><span class="s1">)</span>
<span class="s1">Performance = Performance.dropna()</span>


<span class="s3"># TODO: *! Table 1.</span>
<span class="s1">fig = make_subplots(rows=</span><span class="s4">1</span><span class="s0">, </span><span class="s1">cols=</span><span class="s4">2</span><span class="s0">,</span>
                    <span class="s1">subplot_titles=(</span><span class="s2">&quot;Agg 10d log portfolio returns&quot;</span><span class="s0">,</span>
                                    <span class="s2">&quot;Agg 10d log portfolio performance vs. benchmark&quot;</span><span class="s1">))</span>
<span class="s1">fig.append_trace(go.Scatter(</span>
    <span class="s1">x=Returns[</span><span class="s2">&quot;Date&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">y=Returns[</span><span class="s2">&quot;Agg Return&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">mode=</span><span class="s2">&quot;lines&quot;</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">row=</span><span class="s4">1</span><span class="s0">, </span><span class="s1">col=</span><span class="s4">1</span><span class="s1">)</span>
<span class="s1">fig.append_trace(go.Scatter(</span>
    <span class="s1">x=Performance[</span><span class="s2">&quot;Date&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">y=Performance[</span><span class="s2">&quot;Agg Performance&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">mode=</span><span class="s2">&quot;lines&quot;</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">row=</span><span class="s4">1</span><span class="s0">, </span><span class="s1">col=</span><span class="s4">2</span><span class="s1">)</span>
<span class="s1">fig.update_xaxes(title_text=</span><span class="s2">&quot;Date&quot;</span><span class="s0">, </span><span class="s1">row=</span><span class="s4">1</span><span class="s0">, </span><span class="s1">col=</span><span class="s4">1</span><span class="s1">)</span>
<span class="s1">fig.update_xaxes(title_text=</span><span class="s2">&quot;Date&quot;</span><span class="s0">, </span><span class="s1">row=</span><span class="s4">1</span><span class="s0">, </span><span class="s1">col=</span><span class="s4">2</span><span class="s1">)</span>
<span class="s1">fig.update_yaxes(title_text=</span><span class="s2">&quot;Log Return&quot;</span><span class="s0">, </span><span class="s1">row=</span><span class="s4">1</span><span class="s0">, </span><span class="s1">col=</span><span class="s4">1</span><span class="s1">)</span>
<span class="s1">fig.update_yaxes(title_text=</span><span class="s2">&quot;Log Performance&quot;</span><span class="s0">, </span><span class="s1">row=</span><span class="s4">1</span><span class="s0">, </span><span class="s1">col=</span><span class="s4">2</span><span class="s1">)</span>
<span class="s1">py.plot(fig</span><span class="s0">, </span><span class="s1">filename=</span><span class="s2">&quot;Table1_LogPerformance.html&quot;</span><span class="s1">)</span>


<span class="s3"># Plot historic rolling 250d drawdown</span>
<span class="s1">Drawdown_Data = pd.DataFrame()</span>
<span class="s1">Roll_Max = (</span><span class="s4">1</span><span class="s1">+Returns[</span><span class="s2">&quot;Agg Return&quot;</span><span class="s1">]).rolling(</span><span class="s4">250</span><span class="s0">, </span><span class="s1">min_periods=</span><span class="s4">1</span><span class="s1">).max()</span>
<span class="s1">Daily_Drawdown = (</span><span class="s4">1</span><span class="s1">+Returns[</span><span class="s2">&quot;Agg Return&quot;</span><span class="s1">]) / Roll_Max - </span><span class="s4">1.0</span>
<span class="s1">Max_Daily_Drawdown = Daily_Drawdown.rolling(</span><span class="s4">250</span><span class="s0">, </span><span class="s1">min_periods=</span><span class="s4">1</span><span class="s1">).min()</span>
<span class="s1">Drawdown_Data[</span><span class="s2">&quot;Date&quot;</span><span class="s1">] = Returns[</span><span class="s2">&quot;Date&quot;</span><span class="s1">]</span>
<span class="s1">Drawdown_Data[</span><span class="s2">&quot;Rolling 250d Drawdown&quot;</span><span class="s1">] = Daily_Drawdown</span>
<span class="s1">Drawdown_Data[</span><span class="s2">&quot;Max 250d Drawdown&quot;</span><span class="s1">] = Max_Daily_Drawdown</span>

<span class="s3"># TODO: !* Table 2.</span>
<span class="s1">fig = px.line(Drawdown_Data</span><span class="s0">, </span><span class="s1">x=</span><span class="s2">&quot;Date&quot;</span><span class="s0">, </span><span class="s1">y=[</span><span class="s2">&quot;Rolling 250d Drawdown&quot;</span><span class="s0">, </span><span class="s2">&quot;Max 250d Drawdown&quot;</span><span class="s1">])</span>
<span class="s1">fig.update_layout(title=</span><span class="s2">&quot;Historic 250d drawdown of agg. portfolio returns&quot;</span><span class="s0">,</span>
                  <span class="s1">xaxis_title=</span><span class="s2">&quot;250d window ending date&quot;</span><span class="s0">,</span>
                  <span class="s1">yaxis_title=</span><span class="s2">&quot;250d Drawdown&quot;</span><span class="s1">)</span>
<span class="s1">py.plot(fig</span><span class="s0">, </span><span class="s1">filename=</span><span class="s2">&quot;Table2_portfolio_drawdown.html&quot;</span><span class="s1">)</span>


<span class="s3"># TODO: *! Table 3.</span>
<span class="s3"># TODO: Deprecated; Decided not to use this chart. Don't delete though?</span>

<span class="s3"># Max drawdown is on 08/2014. Show cumulative return starting from 07/2013.</span>
<span class="s3"># Return_Subset = Returns[Returns[&quot;Date&quot;] &gt;= &quot;2013-07-01&quot;].copy()</span>
<span class="s3"># Return_Subset[&quot;Cumulative Return&quot;] = np.cumproduct(1 + Return_Subset[&quot;Agg Return&quot;])</span>
<span class="s3"># Return_Subset[&quot;Log Cum Return&quot;] = np.log(Return_Subset[&quot;Cumulative Return&quot;])</span>
<span class="s3"># fig = px.line(Return_Subset, x=&quot;Date&quot;, y=&quot;Log Cum Return&quot;)</span>
<span class="s3"># fig.update_layout(title=&quot;Cumulative return from just before largest drawdown occurs&quot;,</span>
<span class="s3">#                   xaxis_title=&quot;Date&quot;,</span>
<span class="s3">#                   yaxis_title=&quot;Log Cumulative Return&quot;)</span>
<span class="s3"># py.plot(fig, filename=&quot;Table3_cumulativeLogPerformance.html&quot;)</span>


<span class="s3"># TODO: *! Table 3.</span>
<span class="s1">Performance[</span><span class="s2">&quot;Cum Performance&quot;</span><span class="s1">] = np.cumsum(Performance[</span><span class="s2">&quot;Agg Performance&quot;</span><span class="s1">])</span>
<span class="s1">fig = px.line(Performance</span><span class="s0">, </span><span class="s1">x=</span><span class="s2">&quot;Date&quot;</span><span class="s0">, </span><span class="s1">y=</span><span class="s2">&quot;Cum Performance&quot;</span><span class="s1">)</span>
<span class="s1">fig.update_layout(title=</span><span class="s2">&quot;Cumulative sum of log 10d performance vs. benchmark&quot;</span><span class="s0">,</span>
                  <span class="s1">xaxis_title=</span><span class="s2">&quot;Date&quot;</span><span class="s0">,</span>
                  <span class="s1">yaxis_title=</span><span class="s2">&quot;Cumulative Log Performance&quot;</span><span class="s1">)</span>
<span class="s1">py.plot(fig</span><span class="s0">, </span><span class="s1">filename=</span><span class="s2">&quot;Table3_CumLogPerformance.html&quot;</span><span class="s1">)</span>

<span class="s3"># (!) Number of occurrences each year?</span>
<span class="s1">signalsCount = data.groupby(</span><span class="s2">&quot;tradedate&quot;</span><span class="s1">).agg(n_signals=(</span><span class="s2">&quot;signal&quot;</span><span class="s0">, </span><span class="s2">&quot;sum&quot;</span><span class="s1">))</span>
<span class="s1">fig = px.scatter(signalsCount</span><span class="s0">, </span><span class="s1">x=signalsCount.index</span><span class="s0">, </span><span class="s1">y=[</span><span class="s2">&quot;n_signals&quot;</span><span class="s1">])</span>
<span class="s1">fig.update_layout(title=</span><span class="s2">&quot;Number of daily trade signals&quot;</span><span class="s0">,</span>
                  <span class="s1">xaxis_title=</span><span class="s2">&quot;Date&quot;</span><span class="s0">,</span>
                  <span class="s1">yaxis_title=</span><span class="s2">&quot;N Signals&quot;</span><span class="s1">)</span>
<span class="s1">py.plot(fig</span><span class="s0">, </span><span class="s1">filename=</span><span class="s2">&quot;Table5_nOccurrences1.html&quot;</span><span class="s1">)</span>

<span class="s1">data[</span><span class="s2">&quot;Year&quot;</span><span class="s1">] = data[</span><span class="s2">&quot;tradedate&quot;</span><span class="s1">].dt.year</span>
<span class="s1">data[</span><span class="s2">&quot;Month&quot;</span><span class="s1">] = data[</span><span class="s2">&quot;tradedate&quot;</span><span class="s1">].dt.month</span>
<span class="s1">signalsCount = data.groupby([</span><span class="s2">&quot;Year&quot;</span><span class="s0">, </span><span class="s2">&quot;Month&quot;</span><span class="s1">]).agg(n_signals=(</span><span class="s2">&quot;signal&quot;</span><span class="s0">, </span><span class="s2">&quot;sum&quot;</span><span class="s1">))</span>

<span class="s1">fig = px.scatter(signalsCount</span><span class="s0">, </span><span class="s1">x=signalsCount.index.get_level_values(</span><span class="s4">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">y=[</span><span class="s2">&quot;n_signals&quot;</span><span class="s1">])</span>
<span class="s1">fig.update_layout(title=</span><span class="s2">&quot;Range of monthly trade signals&quot;</span><span class="s0">,</span>
                  <span class="s1">xaxis_title=</span><span class="s2">&quot;Year&quot;</span><span class="s0">,</span>
                  <span class="s1">yaxis_title=</span><span class="s2">&quot;Trade Signals Per Month&quot;</span><span class="s0">,</span>
                  <span class="s1">showlegend=</span><span class="s0">False</span><span class="s1">)</span>
<span class="s1">py.plot(fig</span><span class="s0">, </span><span class="s1">filename=</span><span class="s2">&quot;Table6_nOccurrences2.html&quot;</span><span class="s1">)</span>

<span class="s3"># (!) Find skewness of the aggregated strategy performance</span>
<span class="s1">mean_performance = np.mean(Performance[</span><span class="s2">&quot;Agg Performance&quot;</span><span class="s1">])  </span><span class="s3"># TODO: (* Figure 1.) Mean 10d performance</span>
<span class="s1">std_performance = np.std(Performance[</span><span class="s2">&quot;Agg Performance&quot;</span><span class="s1">])  </span><span class="s3"># TODO: (*Figure 2.) Std of 10d performance</span>
<span class="s1">skew_performance = scipy.stats.skew(Performance[</span><span class="s2">&quot;Agg Performance&quot;</span><span class="s1">])  </span><span class="s3"># TODO: (* Figure 3.) Skew of 10d performance</span>
<span class="s1">stErr_performance = scipy.stats.sem(Performance[</span><span class="s2">&quot;Agg Performance&quot;</span><span class="s1">])  </span><span class="s3"># TODO: (* Figure 4.) StErr of 10d performance</span>

<span class="s1">Sharpe_ratio = </span><span class="s4">1</span><span class="s1">+np.mean(Returns[</span><span class="s2">&quot;Agg Return&quot;</span><span class="s1">] - \</span>
               <span class="s1">Portfolios[Portfolios[</span><span class="s2">&quot;Date&quot;</span><span class="s1">].isin(Returns[</span><span class="s2">&quot;Date&quot;</span><span class="s1">])][</span><span class="s2">&quot;Rf&quot;</span><span class="s1">] /\</span>
               <span class="s1">np.std(Returns[</span><span class="s2">&quot;Agg Return&quot;</span><span class="s1">]))  </span><span class="s3"># TODO: (* Figure 5.) Daily Sharpe ratio</span>
<span class="s1">Tracking_error = np.std(Performance[</span><span class="s2">&quot;Agg Performance&quot;</span><span class="s1">])  </span><span class="s3"># TODO: (*Figure 6.) Daily tracking error</span>
<span class="s3"># TODO: (*Figure 7.) Daily information ratio</span>
<span class="s1">Information_ratio = </span><span class="s4">1</span><span class="s1">+np.mean(Performance[</span><span class="s2">&quot;Agg Performance&quot;</span><span class="s1">] / Tracking_error)</span>


<span class="s3"># (!) Compute R^2 to see if strategy is related to Momentum anomaly</span>
<span class="s1">FF_MOM = pd.read_csv(</span><span class="s2">&quot;./FF_MOM.csv&quot;</span><span class="s1">)</span>
<span class="s1">FF_MOM[</span><span class="s2">&quot;Date&quot;</span><span class="s1">] = pd.to_datetime(FF_MOM[</span><span class="s2">&quot;Date&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">format=</span><span class="s2">&quot;%Y-%m-%d&quot;</span><span class="s1">)</span>
<span class="s1">FF_MOM[</span><span class="s2">&quot;MOM&quot;</span><span class="s1">] = FF_MOM[</span><span class="s2">&quot;Mom%&quot;</span><span class="s1">] / </span><span class="s4">100</span>

<span class="s1">Returns = Returns.merge(FF_MOM</span><span class="s0">, </span><span class="s1">how=</span><span class="s2">&quot;left&quot;</span><span class="s0">, </span><span class="s1">on=</span><span class="s2">&quot;Date&quot;</span><span class="s1">)</span>
<span class="s1">X_values = (</span><span class="s4">1</span><span class="s1">+Returns[</span><span class="s2">&quot;MOM&quot;</span><span class="s1">]).rolling(</span><span class="s4">10</span><span class="s1">).apply(np.prod</span><span class="s0">, </span><span class="s1">raw=</span><span class="s0">True</span><span class="s1">) - </span><span class="s4">1</span>
<span class="s1">y_values = Returns[</span><span class="s2">&quot;Agg Return&quot;</span><span class="s1">]</span>
<span class="s1">attribution_data = pd.DataFrame()</span>
<span class="s1">attribution_data[</span><span class="s2">&quot;X&quot;</span><span class="s1">] = X_values</span>
<span class="s1">attribution_data[</span><span class="s2">&quot;y&quot;</span><span class="s1">] = y_values</span>
<span class="s1">attribution_data.dropna(inplace=</span><span class="s0">True</span><span class="s1">)</span>

<span class="s1">correlation_matrix = np.corrcoef(attribution_data[</span><span class="s2">&quot;X&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">attribution_data[</span><span class="s2">&quot;y&quot;</span><span class="s1">])</span>
<span class="s1">correlation_xy = correlation_matrix[</span><span class="s4">0</span><span class="s0">,</span><span class="s4">1</span><span class="s1">]</span>
<span class="s1">r_squaredMOM = correlation_xy**</span><span class="s4">2</span>

<span class="s3"># TODO: This is for exporting.</span>
<span class="s3"># Portfolios.to_csv(&quot;./Portfolios.csv&quot;)</span>
<span class="s3"># Portfolios_Shortened.to_csv(&quot;./PortfoliosReturns_ByWeekIdx.csv&quot;)</span>
<span class="s3"># data.to_csv(&quot;./Worked_Data.csv&quot;)</span>
</pre>
</body>
</html>